/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
    //这题需要画图论证，我们发现dp[3]就三种情况，1，2,3分别作为头节点
    //元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 = dp[2]*dp[0]
    //元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 = dp[1]*dp[1]
    //元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量 = dp[0]*dp[2]
    //所以就能够得到递推公式，dp[i] += dp[j - 1] * dp[i - j]，dp[j-1]为以j为头节点左子树的数量，dp[i-j]为以j为头节点右子树的数量
    //首先初始化dp数组，dp[i]表示1~i个数字组成的二叉搜索树数量
    let dp = new Array(n+1).fill(0)
    //dp[0]给一个初始值1，因为空二叉树也算是一颗二叉树
    dp[0]=1
    //从1开始推导dp[i]
    for(let i=1;i<=n;i++){
        //j=当前头节点，分别以1,2,3...为头节点
        for(let j=1;j<=i;j++){
            dp[i]+=dp[j-1]*dp[i-j]
        }
    }
    return dp[n]
};
