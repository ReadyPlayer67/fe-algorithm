/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
  //这道题核心思想就是：一个丑数只有可能由之前的某一个丑数乘以2或3或5得到
  //那么我们从1开始数往后数丑数，并确保数出来的丑数是递增的
  //可以用最小堆来做：我们由1得到丑数2,3,5，push到堆中，并返回此时的堆顶元素2，这就是第二个丑数
  //然后我们继续由2得到下一批丑数：4,5,10，push到堆中并返回对顶元素，第三个丑数3依此类推...
  //但其实用动态规划时间复杂度会更低，初始化一个dp数组，dp[i]就是第i个丑数
  let dp = new Array(n+1).fill(0)
  dp[1]=1
  //初始化三个指针p2,p3,p5，分别表示还没有使用乘2/3/5的丑数的位置（因为任何丑数都是由前面某一个丑数乘以2或3或5得到）
  //默认都是1
  let p2 = 1,p3=1,p5=1
  //开始数丑数，从第二个开始数起
  for(let i=2;i<=n;i++){
    //对当前三个位置分别使用一次次乘2机会，乘3机会，乘5机会，看看哪个最小，最小的那个就是下一个丑数
    const num2 = dp[p2]*2
    const num3 = dp[p3]*3
    const num5 = dp[p5]*5
    dp[i] = Math.min(Math.min(num2, num3), num5)
    //得到下一个丑数的指针位置加一，因为它对应的那次乘法使用完了
    //这里注意不是if else if
    //因为如果找到了下一个丑数10,p2和p5都要+1，因为5*2=10,2*5=10
    //这样确保10只会数一次
    if(dp[i] === num2){
      p2++
    }
    if(dp[i] === num3){
      p3++
    }
    if(dp[i] === num5){
      p5++
    }
  }
  return dp[n]
};
