/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    //这一题因为至多可以交易两次，所以每一天我们就有四种状态：
    const len = prices.length
    let dp = new Array(len).fill(0).map(x => {
        return new Array(5).fill(0)
    })
    //第一种状态：一次交易都没有发生，第一天身上的现金就是0
    dp[0][0]=0
    //第二种状态，发生了一次买入，第一天身上的现金就是-prices[i]
    dp[0][1]=-prices[0]
    //第三种状态，发生了一次买入一次卖出，都发生在第一天现金还是0
    dp[0][2]=0
    //第四种状态，发生了两次买入一次卖出，第一天身上的现金就是-prices[i]
    dp[0][3]=-prices[0]
    //第四种状态，发生了两次买入两次卖出，发生在第一天的话身上现金还是0
    dp[0][4]=0
    for(let i=1;i<len;i++){
        //一次交易都不发生，无论是第几天收益都是0
        dp[i][0] = dp[i-1][0]
        //第i天发生了一次买入，可能是当天买的，那么此时身上的现金就是前一天没有发生交易的金额减去prices[i]
        // 可能是之前买的，那么现金等于前一天同状态的金额，两者取最大值就是第i天的状态
        dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i])
        //第i天发生过了一次买入和卖出，可能是当天卖出的，那么此时身上的现金就是前一天发生了一次买入的现金加上prices[i]
        //可能是之前就已经卖出了，那么现金等于前一天同状态的金额，两者取最大值就是第i天的状态
        dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]+prices[i])
        //同理可递推出第i天发生了两次买入，一次卖出和两次买入，两次卖出的状态
        dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i])
        dp[i][4] = Math.max(dp[i-1][4],dp[i-1][3]+prices[i])
    }
    //现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出,所以最终最大利润是dp[len-1][4]
    return dp[len-1][4]
};
